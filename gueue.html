<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ぐー数分解</title>
    <!-- Tailwind CSSを読み込み、スタイリングに使用します -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Interフォントを読み込みます -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* 全体のフォントをInterに設定し、背景色を調整します */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* 明るい青灰色の背景 */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-xl shadow-lg w-full max-w-md">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">ぐー数分解ツール</h1>

        <div class="mb-4">
            <label for="numberInput" class="block text-gray-700 text-sm font-semibold mb-2">
                ぐー数分解したい数字を入力してください:
            </label>
            <input
                type="number"
                id="numberInput"
                placeholder="例: 10, 0.75"
                class="shadow-sm appearance-none border rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-200 ease-in-out"
                step="any" /* 小数点以下の入力も許可します */
            >
        </div>

        <button
            id="decomposeButton"
            class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition duration-200 ease-in-out transform hover:scale-105"
        >
            ぐー数分解する
        </button>

        <div id="loadingIndicator" class="hidden text-center mt-4 text-blue-600">
            計算中...
        </div>

        <div id="resultArea" class="mt-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
            <h2 class="text-lg font-semibold text-gray-800 mb-2">結果:</h2>
            <p id="decompositionResult" class="text-gray-700 whitespace-pre-wrap"></p>
        </div>

        <!-- メッセージ表示用のボックス -->
        <div id="messageBox" class="hidden mt-4 p-3 rounded-lg text-sm" role="alert"></div>
    </div>

    <script>
        // Define original guusuu numbers, now including factorials of guusuu numbers (5! and 7!)
        const originalGuusuuNumbers = [
            0.75, 1, 5, 7, 19, 31, 33, 47, 206, 519, 821, 1381, 4137,
            120, // 5!
            5040 // 7!
        ];

        // Map to store how each number should be displayed (e.g., "5!", "3 * 7")
        // Prioritize specific representations (3/4, factorials, then products, then original number)
        const displayRepresentationMap = new Map();

        // 1. Add original guusuu numbers to the map with their default string representation
        originalGuusuuNumbers.forEach(num => {
            displayRepresentationMap.set(num, num.toString());
        });
        // Special case for 3/4
        displayRepresentationMap.set(0.75, "3/4");
        // Special cases for guusuu factorials
        displayRepresentationMap.set(120, "5!"); // 5! = 120
        displayRepresentationMap.set(5040, "7!"); // 7! = 5040

        // Helper to calculate factorial (though not directly used for generating terms anymore, useful for reference)
        function calculateFactorial(n) {
            if (n < 0) return NaN;
            if (n === 0 || n === 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) {
                res *= i;
            }
            return res;
        }

        // The basic terms for BFS (sum/difference) are now just the originalGuusuuNumbers
        const basicTermsForBFS = Array.from(new Set([...originalGuusuuNumbers]));
        basicTermsForBFS.sort((a, b) => a - b);


        // 2. Add products of original guusuu numbers to the terms and display map
        let allPossibleTerms = new Set([...basicTermsForBFS]); // Start with basic terms
        for (let i = 0; i < originalGuusuuNumbers.length; i++) {
            for (let j = 0; j < originalGuusuuNumbers.length; j++) {
                const g1 = originalGuusuuNumbers[i];
                const g2 = originalGuusuuNumbers[j];
                const product = g1 * g2;

                // Add to set of all possible terms
                allPossibleTerms.add(product);

                // Store display string for products, but only if not already mapped by a higher priority (factorial or 3/4)
                if (!displayRepresentationMap.has(product)) {
                    // To ensure products like 1*X are not displayed as "1*X" but as "X"
                    if (g1 === 1) {
                        displayRepresentationMap.set(product, displayRepresentationMap.get(g2) || g2.toString());
                    } else if (g2 === 1) {
                        displayRepresentationMap.set(product, displayRepresentationMap.get(g1) || g1.toString());
                    } else {
                        displayRepresentationMap.set(product, `${displayRepresentationMap.get(g1) || g1} * ${displayRepresentationMap.get(g2) || g2}`);
                    }
                }
            }
        }

        // Convert set to array for decomposition algorithm (for DP, includes products)
        const allTermsForDP = Array.from(allPossibleTerms);
        allTermsForDP.sort((a, b) => a - b); // Sort for DP efficiency
        
        // 0.75 (3/4)を正確に扱うために、すべての数値を4倍して整数として扱います
        const scaleFactor = 4;

        /**
         * メッセージボックスにメッセージを表示する関数
         * @param {string} message - 表示するメッセージ
         * @param {'info'|'success'|'error'} type - メッセージの種類 (色分けに使用)
         */
        function showMessage(message, type = 'info') {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = message;
            // 以前のスタイルクラスを削除し、新しいタイプに応じたクラスを追加します
            messageBox.classList.remove('hidden', 'bg-red-100', 'text-red-700', 'bg-green-100', 'text-green-700', 'bg-blue-100', 'text-blue-700');
            if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-700');
            } else if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-700');
            } else { // info
                messageBox.classList.add('bg-blue-100', 'text-blue-700');
            }
            messageBox.style.display = 'block'; // 表示を確実にします
        }

        /**
         * メッセージボックスを非表示にする関数
         */
        function hideMessage() {
            document.getElementById('messageBox').classList.add('hidden');
        }

        /**
         * 指定された数字をぐー数のみの項で構成された計算に分解する関数 (動的計画法を使用)
         * 「できるだけ少ない項の数で」という要件を満たすため、動的計画法を使用します。
         * これにより、最短の経路（最も少ない項数）が保証されます。
         * これは、一般的な「両替問題」の解法に準拠しています。
         *
         * @param {number} target - ぐー数分解したい数値
         * @param {number[]} availableTerms - 分解に使用できるぐー数の配列 (正の数のみ)
         * @returns {number[]|null} - 分解されたぐー数の配列、または分解できない場合はnull
         */
        function guusuuDecompositionDP_SumOnly(target, availableTerms) {
            const scaledTarget = Math.round(target * scaleFactor);
            const scaledTerms = availableTerms.map(num => Math.round(num * scaleFactor));
            scaledTerms.sort((a, b) => a - b);

            const dp = new Array(scaledTarget + 1).fill(Infinity);
            const path = new Array(scaledTarget + 1).fill(null);

            dp[0] = 0;

            for (let i = 1; i <= scaledTarget; i++) {
                for (const guusuu of scaledTerms) {
                    if (i - guusuu >= 0 && dp[i - guusuu] !== Infinity) {
                        if (dp[i - guusuu] + 1 < dp[i]) {
                            dp[i] = dp[i - guusuu] + 1;
                            path[i] = guusuu;
                        }
                    }
                }
            }

            if (dp[scaledTarget] === Infinity) {
                return null;
            }

            const result = [];
            let currentSum = scaledTarget;
            while (currentSum > 0) {
                const lastGuusuuScaled = path[currentSum];
                if (lastGuusuuScaled === null) {
                    console.error("Path reconstruction error in DP: lastGuusuuScaled is null for currentSum", currentSum);
                    return null;
                }
                result.push(lastGuusuuScaled / scaleFactor);
                currentSum -= lastGuusuuScaled;
            }

            return result.reverse();
        }

        /**
         * 指定された数字をぐー数のみの項で構成された計算に分解する関数 (BFSを使用し、和と差を考慮)
         * 「できるだけ少ない項の数で」という要件を満たすため、幅優先探索 (BFS) を使用します。
         * これにより、最短の経路（最も少ない項数）が保証されます。
         *
         * @param {number} target - ぐー数分解したい数値
         * @param {number[]} availableTerms - 分解に使用できるぐー数の配列 (正の数のみ)
         * @returns {number[]|null} - 分解されたぐー数の配列 (正負の数を含む)、または分解できない場合はnull
         */
        function guusuuDecompositionBFS_SumDiff(target, availableTerms) {
            const scaledTarget = Math.round(target * scaleFactor);
            const scaledTerms = availableTerms.map(num => Math.round(num * scaleFactor));
            scaledTerms.sort((a, b) => a - b);

            const queue = [[0, []]]; // [current_scaled_sum, path_list]
            const visited = new Set();
            visited.add(0);

            // 探索範囲の制限 (フリーズ防止のため)
            // 目標値の約2倍の範囲を探索し、パスの長さも制限します
            const maxAbsScaledValue = Math.max(scaledTarget * 2, 50000); // 最小でも50000の範囲は確保
            const maxPathLength = 10; // 最大項数を制限

            let head = 0;
            while (head < queue.length) {
                const [currentSumScaled, currentPath] = queue[head++];

                // 浮動小数点数の誤差を考慮してターゲットに非常に近いかチェック
                if (Math.abs(currentSumScaled - scaledTarget) < 1) {
                    return currentPath;
                }

                // パスが長くなりすぎたら枝刈り
                if (currentPath.length >= maxPathLength) {
                    continue;
                }

                for (const term of scaledTerms) {
                    // 足し算を試す
                    let nextSum = currentSumScaled + term;
                    if (Math.abs(nextSum) <= maxAbsScaledValue && !visited.has(nextSum)) {
                        visited.add(nextSum);
                        queue.push([nextSum, [...currentPath, term / scaleFactor]]);
                    }

                    // 引き算を試す
                    let nextDiff = currentSumScaled - term;
                    if (Math.abs(nextDiff) <= maxAbsScaledValue && !visited.has(nextDiff)) {
                        visited.add(nextDiff);
                        queue.push([nextDiff, [...currentPath, -term / scaleFactor]]); // 負の数として記録
                    }
                }
                // キューのサイズが大きくなりすぎた場合の安全策 (フリーズ対策)
                if (queue.length > 200000) { // 20万件を超えたら打ち切り
                    console.warn("BFS queue too large, stopping to prevent freeze.");
                    return null;
                }
            }
            return null; // 解が見つからなかった
        }


        // 「ぐー数分解する」ボタンのクリックイベントリスナー
        document.getElementById('decomposeButton').addEventListener('click', async () => {
            const inputElement = document.getElementById('numberInput');
            const resultElement = document.getElementById('decompositionResult');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const decomposeButton = document.getElementById('decomposeButton');

            hideMessage(); // 前のメッセージをクリア
            resultElement.textContent = ''; // 前の結果をクリア

            const inputValue = parseFloat(inputElement.value);

            // 入力値の基本的なバリデーション
            if (isNaN(inputValue)) {
                showMessage("有効な数値を入力してください。", "error");
                return;
            }
            if (inputValue < 0) {
                    showMessage("正の数値を入力してください。", "error");
                    return;
                }

            // ボタンを無効化し、ローディングインジケーターを表示
            decomposeButton.disabled = true;
            loadingIndicator.classList.remove('hidden');

            // UIの更新を許可するために、短い遅延を挟んでから計算を実行します
            setTimeout(() => {
                let finalDecomposition = null;
                let finalTermsCount = Infinity;
                let isSumDiffSolution = false;

                // Step 1: BFS (和と差) で分解を試みる
                // 使用するぐー数は、元のぐー数とぐー数の階乗のみ
                const bfsResult = guusuuDecompositionBFS_SumDiff(inputValue, basicTermsForBFS);
                const bfsTermsCount = bfsResult ? bfsResult.length : Infinity;

                if (bfsResult) {
                    finalDecomposition = bfsResult;
                    finalTermsCount = bfsTermsCount;
                    isSumDiffSolution = true;
                }

                // Step 2: DP (和のみ) で分解を試みる
                // 使用するぐー数は、元のぐー数、ぐー数の階乗、ぐー数同士の積のすべて
                const dpResult = guusuuDecompositionDP_SumOnly(inputValue, allTermsForDP);
                const dpTermsCount = dpResult ? dpResult.length : Infinity;

                // 結果の比較と選択
                if (dpResult) {
                    if (dpTermsCount < finalTermsCount) { // DPの結果の方が項数が少ない場合
                        finalDecomposition = dpResult;
                        finalTermsCount = dpTermsCount;
                        isSumDiffSolution = false;
                    } else if (dpTermsCount === finalTermsCount && !isSumDiffSolution) {
                        // 項数が同じで、かつBFSが解を見つけられなかったか、BFSが選択されていない場合
                        // （つまり、BFSが解を見つけたがDPも同じ項数で、DPが優先されるべきではないが、
                        // ここではDPの結果も考慮する）
                        finalDecomposition = dpResult;
                        finalTermsCount = dpTermsCount;
                        isSumDiffSolution = false;
                    }
                }

                if (finalDecomposition) {
                    // ぐー数、ぐー数の階乗、ぐー数同士の積の表示を整形します
                    const sumString = finalDecomposition.map((num, index) => {
                        const absNum = Math.abs(num);
                        let termString = displayRepresentationMap.has(absNum) ? displayRepresentationMap.get(absNum) : absNum.toString();

                        if (num < 0) {
                            return (index === 0 ? "-" : "- ") + termString; // 最初の項が負の場合とそれ以降で表示を調整
                        } else {
                            return (index === 0 ? "" : "+ ") + termString; // 最初の項が正の場合は"+"をつけない
                        }
                    }).join(' '); // 各項の間はスペースで結合

                    resultElement.textContent = `${inputValue} = ${sumString.trim()} (項数: ${finalDecomposition.length})`;
                    showMessage("ぐー数分解が完了しました。", "success");
                } else {
                    resultElement.textContent = 'この数字はぐー数分解できませんでした。';
                    showMessage("指定された数字は、ぐー数のみの項で構成された計算に直すことができませんでした。", "error");
                }

                // ボタンを再度有効化し、ローディングインジケーターを非表示
                decomposeButton.disabled = false;
                loadingIndicator.classList.add('hidden');
            }, 10); // 10ミリ秒の遅延
        });

        // ページ読み込み時の初期メッセージ表示
        showMessage("ぐー数分解したい数字を入力し、「ぐー数分解する」ボタンを押してください。", "info");
    </script>
</body>
</html>
